using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

// Generated by .NET Reflector from G:\MayBeSoftTool\MayBeSoftTool\bin\Debug\Translator.dll
namespace Translator.Compression
{
    public class LZSS
    {
        const int N = 4096;
        const int F = 18;
        const int THRESHOLD = 2;
        public class LZSS_PACK_DATA               /* stuff for doing LZ compression */
        {
            public int state;                       /* where have we got to in the pack? */
            public int i, c, len, r, s;
            public int last_match_length, code_buf_ptr;
            public byte mask;
            public byte[] code_buf;
            public int match_position;
            public int match_length;
            public int[] lson;                   /* left children, */
            public int[] rson;                 /* right children, */
            public int[] dad;                    /* and parents, = binary search trees */
            public byte[] text_buf;   /* ring buffer, with F-1 extra bytes for string comparison */
            public LZSS_PACK_DATA()
            {
                code_buf = new byte[17];
                lson = new int[N + 1];
                rson = new int[N + 257];
                dad = new int[N + 1];
                text_buf = new byte[N + F - 1];
            }

        }
        public class LZSS_UNPACK_DATA             /* for reading LZ files */
        {
            public int state;                       /* where have we got to? */
            public int i, j, k, r, c;
            public int flags;
            public byte[] text_buf;   /* ring buffer, with F-1 extra bytes
									 for string comparison */
            public LZSS_UNPACK_DATA()
            {
                text_buf = new byte[N + F - 1];
            }
        }


        private static void lzss_inittree(ref LZSS_PACK_DATA dat)
        {
            int i;

            for (i = N + 1; i <= N + 256; i++)
                dat.rson[i] = N;

            for (i = 0; i < N; i++)
                dat.dad[i] = N;
        }

        private static void lzss_insertnode(int r, ref LZSS_PACK_DATA dat)
        {
            int i, p, cmp;

            byte[] text_buf = dat.text_buf;
            byte[] key = new byte[text_buf.Length - r];
            Array.Copy(text_buf, r, key, 0, key.Length);
            cmp = 1;
            //key = &text_buf[r];
            p = N + 1 + key[0];
            dat.rson[r] = dat.lson[r] = N;
            dat.match_length = 0;

            for (; ; )
            {

                if (cmp >= 0)
                {
                    if (dat.rson[p] != N)
                        p = dat.rson[p];
                    else
                    {
                        dat.rson[p] = r;
                        dat.dad[r] = p;
                        return;
                    }
                }
                else
                {
                    if (dat.lson[p] != N)
                        p = dat.lson[p];
                    else
                    {
                        dat.lson[p] = r;
                        dat.dad[r] = p;
                        return;
                    }
                }

                for (i = 1; i < F; i++)
                    if ((cmp = key[i] - text_buf[p + i]) != 0)
                        break;

                if (i > dat.match_length)
                {
                    dat.match_position = p;
                    if ((dat.match_length = i) >= F)
                        break;
                }
            }

            dat.dad[r] = dat.dad[p];
            dat.lson[r] = dat.lson[p];
            dat.rson[r] = dat.rson[p];
            dat.dad[dat.lson[p]] = r;
            dat.dad[dat.rson[p]] = r;
            if (dat.rson[dat.dad[p]] == p)
                dat.rson[dat.dad[p]] = r;
            else
                dat.lson[dat.dad[p]] = r;
            dat.dad[p] = N;                 /* remove p */
        }


        private static void lzss_deletenode(int p, ref LZSS_PACK_DATA dat)
        {
            int q;

            if (dat.dad[p] == N)
                return;     /* not in tree */

            if (dat.rson[p] == N)
                q = dat.lson[p];
            else
                if (dat.lson[p] == N)
                    q = dat.rson[p];
                else
                {
                    q = dat.lson[p];
                    if (dat.rson[q] != N)
                    {
                        do
                        {
                            q = dat.rson[q];
                        } while (dat.rson[q] != N);
                        dat.rson[dat.dad[q]] = dat.lson[q];
                        dat.dad[dat.lson[q]] = dat.dad[q];
                        dat.lson[q] = dat.lson[p];
                        dat.dad[dat.lson[p]] = q;
                    }
                    dat.rson[q] = dat.rson[p];
                    dat.dad[dat.rson[p]] = q;
                }

            dat.dad[q] = dat.dad[p];
            if (dat.rson[dat.dad[p]] == p)
                dat.rson[dat.dad[p]] = q;
            else
                dat.lson[dat.dad[p]] = q;

            dat.dad[p] = N;
        }

        public static byte[] Compress(byte[] buf, int last = 1)
        {
            MemoryStream ms_out = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ms_out);
            LZSS_PACK_DATA dat = new LZSS_PACK_DATA();
           // int outputindex = 0;
            int bufindex = 0;
        //    int ret = 0;
            int size = buf.Length;
            //if (dat.state==2)
            //    goto pos2;
            //else
            //    if (dat.state==1)
            //        goto pos1;

            dat.code_buf[0] = 0;
            /* code_buf[1..16] saves eight units of code, and code_buf[0] works
            as eight flags, "1" representing that the unit is an unencoded
            letter (1 byte), "0" a position-and-length pair (2 bytes).
            Thus, eight units require at most 16 bytes of code. */

            dat.code_buf_ptr = dat.mask = 1;

            dat.s = 0;
            dat.r = N - F;
            lzss_inittree(ref dat);

            for (dat.len = 0; (dat.len < F) && (size > 0); dat.len++)
            {
                dat.text_buf[dat.r + dat.len] = buf[bufindex++];
                if (--size == 0)
                {
                    if (last == 0)
                    {
                        dat.state = 1;
                        goto getout;
                    }
                }
            pos1:
                ;
            }

            if (dat.len == 0)
                goto getout;

            for (dat.i = 1; dat.i <= F; dat.i++)
                lzss_insertnode(dat.r - dat.i, ref dat);
            /* Insert the F strings, each of which begins with one or
            more 'space' characters. Note the order in which these
            strings are inserted. This way, degenerate trees will be
            less likely to occur. */

            lzss_insertnode(dat.r, ref dat);
            /* Finally, insert the whole string just read. match_length
            and match_position are set. */

            do
            {
                if (dat.match_length > dat.len)
                    dat.match_length = dat.len;  /* match_length may be long near the end */

                if (dat.match_length <= THRESHOLD)
                {
                    dat.match_length = 1;  /* not long enough match: send one byte */
                    dat.code_buf[0] |= dat.mask;    /* 'send one byte' flag */
                    dat.code_buf[dat.code_buf_ptr++] = dat.text_buf[dat.r]; /* send uncoded */
                }
                else
                {
                    /* send position and length pair. Note match_length > THRESHOLD */
                    dat.code_buf[dat.code_buf_ptr++] = (byte)dat.match_position;
                    dat.code_buf[dat.code_buf_ptr++] = (byte)
                        (((dat.match_position >> 4) & 0xF0) |
                        (dat.match_length - (THRESHOLD + 1)));
                }

                if ((dat.mask <<= 1) == 0)
                {                  /* shift mask left one bit */

                    for (dat.i = 0; dat.i < dat.code_buf_ptr; dat.i++)
                    {
                        writer.Write((byte)dat.code_buf[dat.i]);
                        //outputbuf[outputindex++] = dat.code_buf[dat.i];
                        //if (pack_ferror(file)) {
                        //if (outputindex > outputsize) {
                        //    ret = EOF;
                        //    goto getout;
                        //}
                    }
                    dat.code_buf[0] = 0;
                    dat.code_buf_ptr = dat.mask = 1;
                }

                dat.last_match_length = dat.match_length;

                for (dat.i = 0; (dat.i < dat.last_match_length) && (size > 0); dat.i++)
                {
                    dat.c = buf[bufindex++];
                    if (--size == 0)
                    {
                        if (last == 0)
                        {
                            dat.state = 2;
                            goto getout;
                        }
                    }
                pos2:
                    lzss_deletenode(dat.s, ref dat);    /* delete old strings and */
                    dat.text_buf[dat.s] = (byte)dat.c;      /* read new bytes */
                    if (dat.s < F - 1)
                        dat.text_buf[dat.s + N] = (byte)dat.c; /* if the position is near the end of
										buffer, extend the buffer to make
										string comparison easier */
                    dat.s = (dat.s + 1) & (N - 1);
                    dat.r = (dat.r + 1) & (N - 1);         /* since this is a ring buffer,
									   increment the position modulo N */

                    lzss_insertnode(dat.r, ref dat);    /* register the string in
									   text_buf[r..r+F-1] */
                }

                while (dat.i++ < dat.last_match_length)
                {   /* after the end of text, */
                    lzss_deletenode(dat.s, ref dat);          /* no need to read, but */
                    dat.s = (dat.s + 1) & (N - 1);               /* buffer may not be empty */
                    dat.r = (dat.r + 1) & (N - 1);
                    if (--dat.len != 0)
                        lzss_insertnode(dat.r, ref dat);
                }

            } while (dat.len > 0);   /* until length of string to be processed is zero */

            if (dat.code_buf_ptr > 1)
            {         /* send remaining code */

                for (dat.i = 0; dat.i < dat.code_buf_ptr; dat.i++)
                {
                    //pack_putc(dat.code_buf[i], file);
                    writer.Write(dat.code_buf[dat.i]);
                    //outputbuf[outputindex++] = dat.code_buf[dat.i];
                    //if (pack_ferror(file)) {
                    //if (outputindex > outputsize) {
                    //    ret = EOF;
                    //    goto getout;
                    //}
                }
            }

            dat.state = 0;

        getout:

            return ms_out.ToArray();
        }

        public static byte[] Decompress(byte[] inputbuf)
        {
            LZSS_UNPACK_DATA dat = new LZSS_UNPACK_DATA();
            MemoryStream ms_out = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ms_out);
            int inputindex = 0;
            //int i = dat.i;
            //int j = dat.j;
            //int k = dat.k;
            //int r = dat.r;
            //int c = dat.c;
            //int flags = dat.flags;
            //int size = 0;

            //if (dat.state == 2)
            //    goto pos2;
            //else
            //    if (dat.state == 1)
            //        goto pos1;
            dat.r = N - F;
            dat.flags = 0;

            for (; ; )
            {
                if (((dat.flags >>= 1) & 256) == 0)
                {
                    dat.c = inputbuf[inputindex++];
                    if (inputindex > inputbuf.Length)
                    {
                        break;
                    }
                    dat.flags = dat.c | 0xFF00;        /* uses higher byte to count eight */
                }
                if ((dat.flags & 1) != 0)
                {
                    dat.c = inputbuf[inputindex++];
                    if (inputindex > inputbuf.Length)
                    {
                        break;
                    }
                    dat.text_buf[dat.r++] = (byte)dat.c;
                    dat.r &= (N - 1);
                    writer.Write((byte)dat.c);
                //if (++size >= s)
                //{
                //    dat.state = 1;
                //    goto getout;
                //}
                pos1:
                    ;
                }
                else
                {
                    //if ((i = pack_getc(file)) == EOF)
                    //	break;
                    dat.i = inputbuf[inputindex++];
                    if (inputindex > inputbuf.Length)
                    {
                        break;
                    }
                    //if ((j = pack_getc(file)) == EOF)
                    //	break;
                    dat.j = inputbuf[inputindex++];
                    if (inputindex > inputbuf.Length)
                    {
                        break;
                    }
                    dat.i |= ((dat.j & 0xF0) << 4);
                    dat.j = (dat.j & 0x0F) + THRESHOLD;
                    for (dat.k = 0; dat.k <= dat.j; dat.k++)
                    {
                        dat.c = dat.text_buf[(dat.i + dat.k) & (N - 1)];
                        dat.text_buf[dat.r++] = (byte)dat.c;
                        dat.r &= (N - 1);
                        writer.Write((byte)dat.c);
                    //if (++size >= s)
                    //{
                    //    dat->state = 2;
                    //    goto getout;
                    //}
                    pos2:
                        ;
                    }
                }
                if (inputindex >= inputbuf.Length)
                    break;
            }//end while
            dat.state = 0;

        getout:

            //dat.i = i;
            //dat.j = j;
            //dat.k = k;
            //dat.r = r;
            //dat.c = c;
            //dat.flags = flags;

            return ms_out.ToArray();
        }

    }

    public class LZSSCustom
    {
        public static MemoryStream Compress(ref MemoryStream data, string filename)
        {
            try
            {
                uint length = (uint)data.Length;
                MemoryStream memoryStream = new MemoryStream();
                byte[] DecompressedData = data.ToArray();
                uint offset = 0U;
                uint num1 = 4U;
                if (data.Length > 16777215L)
                    throw new Exception("Input file is too large to compress.");
                LzWindowDictionary windowDictionary = new LzWindowDictionary();
                windowDictionary.SetWindowSize(4096);
                windowDictionary.SetMaxMatchAmount(18);
                byte[] bytes = BitConverter.GetBytes((uint)(16 | (int)length << 8));
                memoryStream.Write(bytes, 0, bytes.Length);
                while (offset < length)
                {
                    byte num2 = (byte)0;
                    uint num3 = num1;
                    memoryStream.WriteByte(num2);
                    ++num1;
                    for (int index = 7; index >= 0; --index)
                    {
                        int[] numArray = windowDictionary.Search(DecompressedData, offset, length);
                        if (numArray[1] > 0)
                        {
                            num2 |= (byte)(1 << index);
                            memoryStream.WriteByte((byte)((numArray[1] - 3 & 15) << 4 | (numArray[0] - 1 & 4095) >> 8));
                            memoryStream.WriteByte((byte)(numArray[0] - 1 & (int)byte.MaxValue));
                            windowDictionary.AddEntryRange(DecompressedData, (int)offset, numArray[1]);
                            windowDictionary.SlideWindow(numArray[1]);
                            offset += (uint)numArray[1];
                            num1 += 2U;
                        }
                        else
                        {
                            //num2 = num2;
                            memoryStream.WriteByte(DecompressedData[offset]);
                            windowDictionary.AddEntry(DecompressedData, (int)offset);
                            windowDictionary.SlideWindow(1);
                            ++offset;
                            ++num1;
                        }
                        if (offset >= length)
                            break;
                    }
                    memoryStream.Seek((long)num3, SeekOrigin.Begin);
                    memoryStream.WriteByte(num2);
                    memoryStream.Seek((long)num1, SeekOrigin.Begin);
                }
                return memoryStream;
            }
            catch
            {
                return (MemoryStream)null;
            }
        }

        public static MemoryStream Decompress(byte[] data)
        {
            try
            {
                uint num1 = (uint)data.Length;
                uint num2 = (uint)data[0] + (uint)data[1] * 256U;
                uint num3 = 4U;
                uint num4 = 0U;
                byte[] numArray = data;
                byte[] buffer = new byte[num2];
                while (num3 < num1 && num4 < num2)
                {
                    byte num5 = numArray[num3];
                    ++num3;
                    for (int index1 = 7; index1 >= 0; --index1)
                    {
                        if (((int)num5 & 1 << index1) == 0)
                        {
                            buffer[num4] = numArray[num3];
                            ++num3;
                            ++num4;
                        }
                        else
                        {
                            int num6 = (((int)numArray[num3] & 15) << 8 | (int)numArray[(int)(IntPtr)((long)(num3 + 1U))]) + 1;
                            int num7 = ((int)numArray[num3] >> 4) + 3;
                            num3 += 2U;
                            for (int index2 = 0; index2 < num7; ++index2)
                                buffer[(int)(IntPtr)((long)num4 + (long)index2)] = buffer[(int)(IntPtr)((long)num4 - (long)num6 + (long)index2)];
                            num4 += (uint)num7;
                        }
                        if (num3 >= num1 || num4 >= num2)
                            break;
                    }
                }
                return new MemoryStream(buffer);
            }
            catch
            {
                return (MemoryStream)null;
            }
        }

        public static byte[] Decompress(byte[] data, uint out_len)
        {
            try
            {
                uint num1 = (uint)data.Length;
                uint num2 = out_len;
                uint num3 = 0U;
                uint num4 = 0U;
                byte[] numArray1 = data;
                byte[] numArray2 = new byte[num2];
                while (num3 < num1 && num4 < num2)
                {
                    byte num5 = numArray1[num3];
                    ++num3;
                    for (int index1 = 7; index1 >= 0; --index1)
                    {
                        if (((int)num5 & 1 << index1) == 0)
                        {
                            numArray2[num4] = numArray1[num3];
                            ++num3;
                            ++num4;
                        }
                        else
                        {
                            int num6 = (((int)numArray1[num3] & 15) << 8 | (int)numArray1[(int)(IntPtr)((long)(num3 + 1U))]) + 1;
                            int num7 = ((int)numArray1[num3] >> 4) + 3;
                            num3 += 2U;
                            for (int index2 = 0; index2 < num7; ++index2)
                                numArray2[(int)(IntPtr)((long)num4 + (long)index2)] = numArray2[(int)(IntPtr)((long)num4 - (long)num6 + (long)index2)];
                            num4 += (uint)num7;
                        }
                        if (num3 >= num1 || num4 >= num2)
                            break;
                    }
                }
                byte[] numArray3 = new byte[num4];
                Array.Copy((Array)numArray2, 0, (Array)numArray3, 0, numArray3.Length);
                return numArray3;
            }
            catch
            {
                return (byte[])null;
            }
        }
    }
}

